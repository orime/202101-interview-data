### 第 83 题：var、let 和 const 区别的实现原理是什么

解析：[第 83 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133)

解答：

区别：

- var 声明的变量会挂载到全局 window 下，并且有提前声明机制，在之前访问该属性值为 undefined；var 声明的变量没有作用域限制，作用域外部也可访问
- let 声明的变量在当前作用域中存在暂存性死区（dead zone），在该行声明代码之前不可以用任何形式访问该变量标识符，有作用域限制，作用域外部不可访问
- const 声明变量和 let 性质类似，这是 const 用来声明常量，值一旦声明之后不可改变

实现原理：

- var: var a = 12 -> window.a = 12
- let: let b = 34 -> 

```javascript

```

#### 总结：

变量与内存之间的关系，主要由三个部分组成：

变量名
内存地址
内存空间
JS 引擎在读取变量时，先找到变量绑定的内存地址，然后找到地址所指向的内存空间，最后读取其中的内容。当变量改变时，JS 引擎不会用新值覆盖之前旧值的内存空间（虽然从写代码的角度来看，确实像是被覆盖掉了），而是重新分配一个新的内存空间来存储新值，并将新的内存地址与变量进行绑定，JS 引擎会在合适的时机进行 GC，回收旧的内存空间。

const 定义变量（常量）后，变量名与内存地址之间建立了一种不可变的绑定关系，阻隔变量地址被改变，当 const 定义的变量进行重新赋值时，根据前面的论述，JS 引擎会尝试重新分配新的内存空间，所以会被拒绝，便会抛出异常。

#### 扩展：

（一）var
var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined 。
内层变量可能覆盖外层变量
用来计数的循环变量泄露为全局变量
（二）let
声明的�全局变量不会挂在顶层对象下面
所声明的变量一定要在声明后使用，否则报错，报错 ReferenceError
暂时性死区，只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（ binding ）这个区域，不再受外部的影响，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。
不允许重复声明
（三）const
声明的�全局变量不会挂在顶层对象下面
const 声明之后必须马上赋值，否则会报错
const 简单类型一旦声明就不能再更改，�复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。
const 一旦声明变量，就必须立即初始化，不能留到以后赋值。
const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
